"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ftp = void 0;
const basic_ftp_1 = require("basic-ftp");
const stream_1 = require("stream");
const path_1 = require("path");
const debug_1 = __importDefault(require("debug"));
const notfound_1 = __importDefault(require("./notfound"));
const notmodified_1 = __importDefault(require("./notmodified"));
const debug = (0, debug_1.default)('get-uri:ftp');
/**
 * Returns a Readable stream from an "ftp:" URI.
 */
const ftp = async (url, opts = {}) => {
    const { cache } = opts;
    const filepath = decodeURIComponent(url.pathname);
    let lastModified;
    if (!filepath) {
        throw new TypeError('No "pathname"!');
    }
    const client = new basic_ftp_1.Client();
    try {
        const host = url.hostname || url.host || 'localhost';
        const port = parseInt(url.port || '0', 10) || 21;
        const user = url.username
            ? decodeURIComponent(url.username)
            : undefined;
        const password = url.password
            ? decodeURIComponent(url.password)
            : undefined;
        await client.access({
            host,
            port,
            user,
            password,
            ...opts,
        });
        // first we have to figure out the Last Modified date.
        // try the MDTM command first, which is an optional extension command.
        try {
            lastModified = await client.lastMod(filepath);
        }
        catch (err) {
            // handle the "file not found" error code
            if (err.code === 550) {
                throw new notfound_1.default();
            }
        }
        if (!lastModified) {
            // Try to get the last modified date via the LIST command (use